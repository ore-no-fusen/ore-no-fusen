'use client';

import { useState, useEffect, useCallback, useRef, memo, useMemo } from 'react';
import React from 'react';
import { useSearchParams } from 'next/navigation';
import { invoke } from '@tauri-apps/api/core';
import { emit, listen } from '@tauri-apps/api/event';
import { getCurrentWindow } from '@tauri-apps/api/window';
import { pathsEqual } from '../utils/pathUtils';
import { playDeleteSound } from '../utils/soundManager';
import { getFontSize } from '../utils/settingsManager';
import RichTextEditor, { RichTextEditorRef } from './RichTextEditor';
import ConfirmDialog from './ConfirmDialog';

import { useSettings } from "@/lib/settings-store";
import { getTranslation, type Language } from "@/lib/i18n";

// 蝙句ｮ夂ｾｩ
type NoteMeta = {
    path: string;
    seq: number;
    context: string;
    updated: string;
    x?: number;
    y?: number;
    width?: number;
    height?: number;
    background_color?: string;
    always_on_top?: boolean;
};

type Note = {
    body: string;
    frontmatter: any;
    meta: NoteMeta;
};

// 繝ｦ繝ｼ繝・ぅ繝ｪ繝・ぅ髢｢謨ｰ
function splitFrontMatter(src: string) {
    if (!src.startsWith('---')) return { front: '', body: src };
    const end = src.indexOf('\n---', 3);
    if (end === -1) return { front: '', body: src };
    const front = src.slice(0, end + 4);
    const body = src.slice(end + 4).replace(/^\s+/, '');
    return { front, body };
}

function getFileName(path: string) {
    return path.split(/[\\/]/).pop() || path;
}

const showSaveError = () => {
    console.error('Save failed');
};

const StickyNote = memo(function StickyNote() {
    const searchParams = useSearchParams();
    const urlPath = searchParams.get('path');
    const isNew = searchParams.get('isNew') === '1'; // Fix 2: Define isNew outside useEffect

    const [selectedFile, setSelectedFile] = useState<NoteMeta | null>(null);
    const [content, setContent] = useState<string>('');

    // [i18n]
    const { settings } = useSettings();
    const t = useMemo(() => getTranslation((settings.language as Language) || 'ja'), [settings.language]);

    // [New] Line Offset Calculation for precise cursor positioning
    const lineOffsets = useMemo(() => {
        let offset = 0;
        return (content || '').split('\n').map(line => {
            const current = offset;
            offset += line.length + 1; // +1 for newline character
            return current;
        });
    }, [content]);
    const [loading, setLoading] = useState<boolean>(false);
    const [isEditing, setIsEditing] = useState(false);
    const [editBody, setEditBody] = useState('');
    const [savePending, setSavePending] = useState(false);
    const [cursorPosition, setCursorPosition] = useState<number | null>(null);
    const [isNewNote, setIsNewNote] = useState(false); // [NEW] 譁ｰ隕上ヮ繝ｼ繝医ヵ繝ｩ繧ｰ・・tate邂｡逅・ｼ・
    const textareaRef = useRef<HTMLTextAreaElement>(null);
    const [rawFrontmatter, setRawFrontmatter] = useState<string>('');
    const [noteBackgroundColor, setNoteBackgroundColor] = useState<string>('#f7e9b0');
    const [noteFontSize, setNoteFontSize] = useState<number>(16); // 險ｭ螳壹°繧芽ｪｭ縺ｿ霎ｼ繧繝輔か繝ｳ繝医し繧､繧ｺ
    // 繝ｪ繝阪・繝縺ｫ繧医ｋ譖ｴ譁ｰ縺九←縺・°繧貞愛螳壹☆繧九ヵ繝ｩ繧ｰ
    const isRenamingRef = useRef(false);
    // [Strict Rename] 繧ｳ繝溘ャ繝茨ｼ育ｷｨ髮・ｵゆｺ・ｼ牙・逅・ｸｭ繧ｬ繝ｼ繝・
    const isCommittingRef = useRef(false);

    // [New] Selection & Pointer Refs
    const pendingSelectionRef = useRef<{ start: number; end: number } | null>(null);
    const pointerDownRef = useRef<{ x: number; y: number } | null>(null);

    const lastEditEndedAt = useRef<number>(0);
    // [New] 蛻晄悄繝ｭ繝ｼ繝峨ｄ繝輔か繝ｼ繧ｫ繧ｹ謠ｺ繧後↓繧医ｋ隱､Blur繧帝亟縺舌ち繧､繝槭・
    const ignoreBlurUntilRef = useRef<number>(0);

    const editorRef = useRef<RichTextEditorRef>(null);

    // [Fix] Sync font size from settings
    // [Fix] Sync font size from settings
    useEffect(() => {
        setNoteFontSize(settings.font_size);
    }, [settings.font_size]);

    // [New] Listen for global settings update from backend
    useEffect(() => {
        let unlisten: (() => void) | undefined;
        (async () => {
            try {
                const { listen } = await import('@tauri-apps/api/event');
                unlisten = await listen<any>("settings_updated", (event) => {
                    const newSettings = event.payload;
                    console.log("[STICKY]謾ｶ蛻ｰ險ｭ螳壽峩譁ｰ繧､繝吶Φ繝・", newSettings);
                    if (newSettings && typeof newSettings.font_size === 'number') {
                        console.log("[STICKY] 繝輔か繝ｳ繝医し繧､繧ｺ繧呈峩譁ｰ縺励∪縺・", newSettings.font_size);
                        setNoteFontSize(newSettings.font_size);
                    }
                });
            } catch (e) {
                console.error("Failed to setup settings_updated listener", e);
            }
        })();
        return () => { if (unlisten) unlisten(); };
    }, []);
    const editorHostRef = useRef<HTMLDivElement>(null); // [New boundary ref]
    const editBodyRef = useRef(editBody); // [New] Stale closure fix

    // Sync ref with state for event handlers
    useEffect(() => {
        editBodyRef.current = editBody;
    }, [editBody]);

    // 繝帙ヰ繝ｼ邂｡逅・
    const [isHover, setIsHover] = useState(false);
    const [isDraggableArea, setIsDraggableArea] = useState(false);
    const [isEditableArea, setIsEditableArea] = useState(false);
    const [isCornerArea, setIsCornerArea] = useState(false);
    const [showTagModal, setShowTagModal] = useState(false);
    const [tagInputValue, setTagInputValue] = useState('');
    const [allTags, setAllTags] = useState<string[]>([]);
    const [currentTags, setCurrentTags] = useState<string[]>([]);
    const [isTagDeleteMode, setIsTagDeleteMode] = useState(false);
    const [tagToDelete, setTagToDelete] = useState<string | null>(null);
    const shellRef = useRef<HTMLDivElement>(null);
    const menuRef = useRef<any>(null); // Keep menu alive to prevent GC of callbacks

    // Frontmatter譖ｴ譁ｰ繝倥Ν繝代・
    const updateFrontmatterValue = (front: string, key: string, value: string | number) => {
        // Use exact field names only - no aliases to prevent mismatches
        const regex = new RegExp(`(${key}:\\s*)(.*)`, 'm');
        if (regex.test(front)) {
            return front.replace(regex, `$1${value}`);
        } else {
            const lastFence = front.lastIndexOf('---');
            if (lastFence > 0) {
                return front.slice(0, lastFence) + `${key}: ${value}\n` + front.slice(lastFence);
            }
            if (!front || front.trim() === '') {
                return `---\n${key}: ${value}\n---\n`;
            }
            return front + `\n---\n${key}: ${value}\n---\n`;
        }
    };

    const updateFrontmatterGeometry = (front: string, geom: { x?: number, y?: number, width?: number, height?: number }) => {
        let newFront = front;
        if (geom.x !== undefined) newFront = updateFrontmatterValue(newFront, 'x', Math.round(geom.x));
        if (geom.y !== undefined) newFront = updateFrontmatterValue(newFront, 'y', Math.round(geom.y));
        if (geom.width !== undefined) newFront = updateFrontmatterValue(newFront, 'width', Math.round(geom.width));
        if (geom.height !== undefined) newFront = updateFrontmatterValue(newFront, 'height', Math.round(geom.height));
        return newFront;
    };

    // [New] Link Parser Helper
    const parseLinks = (text: string, baseOffset: number) => {
        // 1. Web URL: http:// or https://
        // 2. Windows Path: 
        //    a) Drive Letter: C:\... (exclude invalid chars)
        //    b) UNC: \\Server\...
        const regex = /((?:https?:\/\/[^\s]+)|(?:[a-zA-Z]:\\[^:<>"\/?*|\r\n]+)|(?:\\\\[^:<>"\/?*|\r\n]+))/g;

        const parts = text.split(regex);
        let currentOffset = 0;

        return parts.map((part, k) => {
            if (part === '') return null;

            const partStart = baseOffset + currentOffset;
            currentOffset += part.length;

            if (regex.test(part)) {
                return (
                    <span
                        key={k}
                        style={{
                            color: 'blue',
                            textDecoration: 'underline',
                            cursor: 'pointer',
                        }}
                        data-src-start={partStart}
                        data-tauri-drag-region="false" // 繝ｪ繝ｳ繧ｯ荳翫・繝峨Λ繝・げ辟｡蜉ｹ蛹・
                        onClick={async (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            console.log('[OpenLink]', part);
                            try {
                                if (/^https?:\/\//i.test(part)) {
                                    const { open } = await import('@tauri-apps/plugin-shell');
                                    await open(part);
                                } else {
                                    const { invoke } = await import('@tauri-apps/api/core');
                                    await invoke('fusen_open_file', { path: part });
                                }
                            } catch (err) {
                                console.error('Failed to open link:', err);
                            }
                        }}
                    >
                        {part}
                    </span>
                );
            }

            return <span key={k} data-src-start={partStart}>{part}</span>;
        });
    };

    // 繧ｦ繧｣繝ｳ繝峨え迥ｶ諷倶ｿ晏ｭ・
    const saveWindowState = useCallback(async () => {
        // [New Feature Instruction for Frontend Dev]
        // Use 'fusen_update_geometry' for efficient persistence without triggering full save.
        // Example: await invoke('fusen_update_geometry', { path: selectedFile.path, x, y, width, height });
        // Ensure to debounce this call (already done in useEffect).

        if (!selectedFile) return;
        try {
            const win = getCurrentWindow();
            const factor = await win.scaleFactor();
            const physPos = await win.outerPosition();
            const physSize = await win.innerSize();

            const x = Math.round(physPos.x / factor);
            const y = Math.round(physPos.y / factor);
            const width = Math.round(physSize.width / factor);
            const height = Math.round(physSize.height / factor);

            setRawFrontmatter(prev => {
                const updated = updateFrontmatterGeometry(prev, { x, y, width, height });
                console.log(`[GEOMETRY] Saved (Logical): x=${x}, y=${y}, w=${width}, h=${height} (Factor: ${factor})`);
                return updated;
            });
            setSavePending(true);
        } catch (e) {
            console.error('Failed to save window state', e);
        }
    }, [selectedFile]);
    // 繝弱・繝井ｿ晏ｭ・
    const saveNote = useCallback(async (path: string, body: string, frontmatter: string, allowRename: boolean) => {
        // [Strict Log]
        console.log('[SAVE]', { allowRename, firstLine: body.split('\n')[0], path });
        console.log('[DEBUG] saveNote called:', { path, bodyLength: body.length, allowRename });
        try {
            const newPath = await invoke<string>('fusen_save_note', {
                path,
                body,
                frontmatterRaw: frontmatter,
                allowRename
            });
            console.log('[DEBUG] saveNote result:', { old: path, new: newPath, renamed: !pathsEqual(newPath, path) });
            if (!pathsEqual(newPath, path)) {
                console.log('File renamed during save:', path, '->', newPath);
                isRenamingRef.current = true; // 繝ｪ繝阪・繝繝輔Λ繧ｰ繧堤ｫ九※繧・

                // [Fix] Update Context and Path in State so UI reflects new title immediately
                const newContext = body.split('\n')[0].trim();
                setSelectedFile(prev => prev ? { ...prev, path: newPath, context: newContext } : null);

                const url = new URL(window.location.href);
                url.searchParams.set('path', newPath);
                window.history.replaceState({}, '', url.toString());
            }
        } catch (e) {
            console.error('save_note failed', e);
        }
    }, []);

    // 閾ｪ蜍穂ｿ晏ｭ・
    useEffect(() => {
        if (!selectedFile || !savePending) return;
        const timer = setTimeout(async () => {
            try {
                console.log('[AUTO_SAVE] Saving note:', selectedFile.path);
                // allowRename: false for auto-save
                await saveNote(selectedFile.path, editBody, rawFrontmatter, false);
                setContent(editBody);
                setSavePending(false);
            } catch (e) {
                showSaveError();
            }
        }, 800);
        return () => clearTimeout(timer);
    }, [selectedFile, rawFrontmatter, editBody, saveNote, savePending]);

    // 繧ｳ繝ｳ繝・Φ繝・ｪｭ縺ｿ霎ｼ縺ｿ
    const loadFileContent = async (noteMeta: NoteMeta): Promise<string> => {
        setLoading(true);
        try {
            const note = await invoke<Note>('fusen_read_note', { path: noteMeta.path });
            const { front, body } = splitFrontMatter(note.body);
            setRawFrontmatter(front);
            setContent(body);
            setEditBody(body);
            setIsEditing(false);

            const colorMatch = front.match(/backgroundColor:\s*["']?([^"'\s]+)["']?/);
            if (colorMatch) {
                setNoteBackgroundColor(colorMatch[1]);
            } else {
                setNoteBackgroundColor('#f7e9b0');
            }
            return body; // [NEW] Return body for immediate use
        } catch (error) {
            console.error('read_note failed', error);
            setContent('');
            return ''; // [NEW] Return empty string on error
        } finally {
            setLoading(false);
        }
    };

    // 蛻晄悄繝ｭ繝ｼ繝・
    useEffect(() => {
        if (!urlPath) return;

        // 繝ｪ繝阪・繝縺ｫ繧医ｋURL譖ｴ譁ｰ縺ｮ蝣ｴ蜷医・縲∝・隱ｭ縺ｿ霎ｼ縺ｿ繧偵せ繧ｭ繝・・
        if (isRenamingRef.current) {
            console.log('[STICKY_LOAD] Skipping reload due to rename:', urlPath);
            isRenamingRef.current = false;
            return;
        }

        console.log('[STICKY_LOAD] Detected path parameter:', urlPath);

        const myNote: NoteMeta = {
            path: urlPath,
            seq: 0,
            context: getFileName(urlPath),
            updated: '',
        };
        setSelectedFile(myNote);

        // 隱ｭ縺ｿ霎ｼ縺ｿ縺ｨ蛻晄悄繝輔か繝ｼ繧ｫ繧ｹ險ｭ螳・
        loadFileContent(myNote).then(async (body) => {
            // Fix 2: Use captured isNew
            if (isNew) {
                console.log('[STICKY_LOAD] New note detected. Enabling edit mode.');
                // 3) 譁ｰ隕丈ｽ懈・譎ゅ・縺励・繧峨￥ Blur 繧堤┌隕悶☆繧・
                ignoreBlurUntilRef.current = Date.now() + 800;
                setIsEditing(true);
                setIsNewNote(true); // [NEW] state縺ｫ菫晏ｭ・

                // Fix 5 (Revert): Editor focus alone was insufficient.
                // Re-enable explicit window focus, but slightly delayed to ensure it happens 
                // AFTER the window is created and ready, supporting the editor focus loop.
                setTimeout(async () => {
                    const win = getCurrentWindow();
                    await win.setFocus();
                    invoke('fusen_force_focus').catch(e => console.error('[STICKY_LOAD] Backend force focus failed:', e));
                }, 100);
            }
        });
    }, [urlPath, isNew]); // Fix 2: Add isNew to dependency array

    // 險ｭ螳壹°繧峨ヵ繧ｩ繝ｳ繝医し繧､繧ｺ繧定ｪｭ縺ｿ霎ｼ繧
    useEffect(() => {
        getFontSize().then(size => {
            setNoteFontSize(size);
        });
    }, []);

    // 繧､繝吶Φ繝医Μ繧ｹ繝翫・險ｭ螳・
    useEffect(() => {
        if (!selectedFile) return;

        let unlistenMove: (() => void) | undefined;
        let unlistenResize: (() => void) | undefined;

        const setupListeners = async () => {
            const win = getCurrentWindow();

            unlistenMove = await win.listen('tauri://move', () => {
                saveWindowState();
            });

            unlistenResize = await win.listen('tauri://resize', () => {
                saveWindowState();
            });
        };

        setupListeners();

        return () => {
            if (unlistenMove) unlistenMove();
            if (unlistenResize) unlistenResize();
        };
    }, [selectedFile, saveWindowState]);

    // Listen for reload events from global tag deletion
    useEffect(() => {
        console.log('[DEBUG] useEffect for reload listener triggered. selectedFile:', selectedFile?.path);

        if (!selectedFile) {
            console.log('[DEBUG] selectedFile is null, skipping listener setup');
            return;
        }

        const setupReloadListener = async () => {
            const { listen } = await import('@tauri-apps/api/event');
            const unlisten = await listen<string>('fusen:reload_note', async (event) => {
                const modifiedPath = event.payload;

                // Normalize paths for comparison (Windows uses backslash, Unix uses forward slash)
                const normalizedModifiedPath = modifiedPath.replace(/\\/g, '/').toLowerCase();
                const normalizedCurrentPath = selectedFile.path.replace(/\\/g, '/').toLowerCase();
                const pathsMatch = normalizedModifiedPath === normalizedCurrentPath;

                console.log('[RELOAD] Normalized modified path:', normalizedModifiedPath);
                console.log('[RELOAD] Normalized current path:', normalizedCurrentPath);
                console.log('[RELOAD] Paths match?', pathsMatch);

                // Only reload if this is the matching window
                if (pathsMatch) {
                    // Directly reload without calling loadFileContent to avoid dependency issues
                    try {
                        const { invoke } = await import('@tauri-apps/api/core');
                        const note = await invoke<Note>('fusen_read_note', { path: selectedFile.path });
                        const { front, body } = splitFrontMatter(note.body);
                        setRawFrontmatter(front);
                        setContent(body);
                        setEditBody(body);

                        const colorMatch = front.match(/backgroundColor:\s*["']?([^"'\s]+)["']?/);
                        if (colorMatch) {
                            setNoteBackgroundColor(colorMatch[1]);
                        }
                    } catch (error) {
                        console.error('[RELOAD] Failed to reload note:', error);
                    }
                }
            });

            return unlisten;
        };

        const cleanupPromise = setupReloadListener();

        return () => {
            cleanupPromise.then(unlisten => unlisten());
        };
    }, [selectedFile]);


    // 閭梧勹濶ｲ螟画峩繧堤｢ｺ螳溘↓蜿肴丐縺輔○繧九◆繧√・useEffect
    useEffect(() => {
        if (shellRef.current) {
            shellRef.current.style.setProperty('background-color', noteBackgroundColor, 'important');
        }
    }, [noteBackgroundColor]);

    // 繝√ぉ繝・け繝懊ャ繧ｯ繧ｹ縺ｮ繝医げ繝ｫ蜃ｦ逅・
    const handleToggleCheckbox = (lineIndex: number) => {
        const lines = (editBody || content).split('\n');
        if (lineIndex < 0 || lineIndex >= lines.length) return;

        const line = lines[lineIndex];
        const taskMatch = line.match(/^([\-\*\+]\s+\[)([ xX])(\]\s+.*)$/);

        if (taskMatch) {
            const isChecked = taskMatch[2].toLowerCase() === 'x';
            const newChar = isChecked ? ' ' : 'x';
            lines[lineIndex] = `${taskMatch[1]}${newChar}${taskMatch[3]}`;

            const newText = lines.join('\n');
            setEditBody(newText);
            setSavePending(true);
        }
    };



    // 邱ｨ髮・Δ繝ｼ繝蛾幕蟋・
    const handleEditStart = (cursorPos?: number) => {
        if (isEditing) return;
        // 2) 邱ｨ髮・幕蟋狗峩蠕後ｂ縺励・繧峨￥ Blur 繧堤┌隕悶☆繧・
        ignoreBlurUntilRef.current = Date.now() + 800;
        setIsEditing(true);
        setEditBody(content); // 譛譁ｰ縺ｮ迥ｶ諷九ｒ繧ｻ繝・ヨ
        setCursorPosition(cursorPos ?? null);
    };

    // 邱ｨ髮・Δ繝ｼ繝臥ｵゆｺ・


    // 邱ｨ髮・・螳ｹ螟画峩
    const handleEditChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
        setEditBody(e.target.value);
        setSavePending(true);
    };

    // 繧ｭ繝ｼ繝懊・繝峨う繝吶Φ繝・
    const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
        if (e.key === 'Escape') {
            handleEditBlur();
        }
    };

    // 繧ｫ繝ｼ繧ｽ繝ｫ菴咲ｽｮ險ｭ螳・& 遽・峇驕ｸ謚槫ｾｩ蜈・
    useEffect(() => {
        if (!isEditing) return;

        const attemptFocus = (count = 0) => {
            if (count > 20) { // Timeout after ~300ms
                return;
            }
            if (editorRef.current) {
                // 遽・峇驕ｸ謚槭′縺ゅｋ蝣ｴ蜷医・縺昴ｌ繧貞ｾｩ蜈・(cursorPosition繧医ｊ蜆ｪ蜈・
                if (pendingSelectionRef.current) {
                    const { start, end } = pendingSelectionRef.current;
                    // 繝悶Λ繧ｦ繧ｶ蛛ｴ縺ｮ驕ｸ謚櫁ｧ｣髯､繧貞・縺ｫ陦後≧
                    window.getSelection()?.removeAllRanges();

                    editorRef.current.focus();
                    editorRef.current.setSelection(start, end);
                    pendingSelectionRef.current = null;
                } else {
                    // Fix 4: Simply request focus on edit start.
                    editorRef.current.focus();
                }
            } else {
                requestAnimationFrame(() => attemptFocus(count + 1));
            }
        };

        attemptFocus();
    }, [isEditing]); // Remove cursorPosition from dependency since RTE handles it

    // [New] Helper to calc offset based on data-src-start
    const calcOffsetFromDomPoint = (node: Node, offset: number): number | null => {
        const el = (node.nodeType === Node.TEXT_NODE
            ? (node.parentElement as HTMLElement | null)
            : (node as HTMLElement | null))?.closest?.("[data-src-start]") as HTMLElement | null;

        if (!el) return null;
        const startStr = el.getAttribute("data-src-start");
        if (!startStr) return null;

        const base = parseInt(startStr, 10);
        if (!Number.isFinite(base)) return null;

        // 譛蟆丞ｮ溯｣・ｼ啜extNode蜀・・offset繧定ｶｳ縺・
        // Note: For non-text nodes (e.g. clicking the element itself), offset might mean child index.
        // But getSelection often returns text nodes. If it returns element, offset is index.
        // For simplicity and safety per user request "minimal implementation":
        // just add max(0, offset) if it makes sense, or treat as base if naive.
        // If node is text node, offset is character offset.
        if (node.nodeType === Node.TEXT_NODE) {
            return base + Math.max(0, offset);
        }
        // If element, usually we want base.
        return base;
    };

    const normalizeRange = (a: number, b: number) => {
        return a <= b ? { start: a, end: b } : { start: b, end: a };
    };

    const onArticlePointerDown = (e: React.PointerEvent) => {

        pointerDownRef.current = { x: e.clientX, y: e.clientY };
        // handleDragStart might also listen to this, but here we track for click/edit logic.
        // handleDragStart uses its own logic.
    };

    const onArticlePointerUp = (e: React.PointerEvent) => {
        // [Refactor] Use setTimeout(0) to wait for selection to settle.
        // Capture coordinates for single click fallback
        const clientX = e.clientX;
        const clientY = e.clientY;
        const target = e.target as HTMLElement;

        // Check if interactive element
        if (target.closest('[data-interactable]')) return;

        pointerDownRef.current = null;

        setTimeout(() => {
            // 1. Check for valid selection (Double click or Drag)
            const sel = window.getSelection();
            if (sel && sel.rangeCount > 0 && sel.toString().length > 0) {
                console.log('[Pointer] Selection detected:', sel.toString());
                const range = sel.getRangeAt(0);
                const start = calcOffsetFromDomPoint(range.startContainer, range.startOffset);
                const end = calcOffsetFromDomPoint(range.endContainer, range.endOffset);

                if (start !== null && end !== null) {
                    pendingSelectionRef.current = normalizeRange(start, end);
                    handleEditStart(); // Selection will be applied by useEffect
                    return;
                }
            }

            // 2. No selection -> Single Click (Cursor positioning)
            // Use caretRangeFromPoint for precise offset
            // (Avoids jumping to line start caused by unstable window.getSelection() on click)
            console.log('[Pointer] No selection, calculating caret position from point.');

            let clickOffset = 0;
            // @ts-ignore - caretRangeFromPoint is widely supported but might be missing in TS lib
            if (document.caretRangeFromPoint) {
                // @ts-ignore
                const range = document.caretRangeFromPoint(clientX, clientY);
                if (range) {
                    const offset = calcOffsetFromDomPoint(range.startContainer, range.startOffset);
                    if (offset !== null) {
                        clickOffset = offset;
                        console.log('[Pointer] Calculated offset from point:', clickOffset);
                    }
                }
            }

            handleEditStart(clickOffset);
        }, 0);
    };






    // [New] Explicit Exit Conditions (Click Outside)
    useEffect(() => {
        if (!isEditing) return;

        const onPointerDownCapture = (e: PointerEvent) => {
            const target = e.target as Node;

            // Editor inner click: ignore
            if (editorHostRef.current?.contains(target)) return;

            // Toolbar click: ignore (if exists, e.g. .hoverBar)
            if ((target as HTMLElement)?.closest?.('.hoverBar')) return;

            // Click Outside: Trigger blur
            console.log('[Boundary] Click outside detected. Ending edit.');
            handleEditBlur();
        };

        window.addEventListener('pointerdown', onPointerDownCapture, true);
        return () => window.removeEventListener('pointerdown', onPointerDownCapture, true);
    }, [isEditing]);



    // 繝峨Λ繝・げ髢句ｧ・
    const handleDragStart = useCallback(async (e: React.PointerEvent) => {
        // 蟾ｦ繧ｯ繝ｪ繝・け(0)莉･螟悶・繝峨Λ繝・げ蜃ｦ逅・＠縺ｪ縺・
        if (e.button !== 0) return;

        // 邱ｨ髮・Δ繝ｼ繝我ｸｭ縺ｪ繧峨√ラ繝ｩ繝・げ縺輔○縺壹↓邱ｨ髮・ｵゆｺ・・逅・ｒ陦後≧
        if (isEditing) {
            e.preventDefault();
            e.stopPropagation();
            handleEditBlur();
            return;
        }

        // 邱ｨ髮・ｵゆｺ・峩蠕・500ms)縺ｯ繧ｬ繝ｼ繝会ｼ亥・邱ｨ髮・・繧企亟豁｢・・
        if (Date.now() - lastEditEndedAt.current < 500) {
            return;
        }

        const target = e.target as HTMLElement;

        // 迚ｹ螳夊ｦ∫ｴ・医・繧ｿ繝ｳ縲√お繝・ぅ繧ｿ縲∵悽譁・ｼ我ｸ翫〒縺ｯ髢句ｧ九＠縺ｪ縺・
        if (target.closest('button') || target.closest('.editorHost') || target.closest('article')) {
            // 繧ｿ繧､繝医Ν繝舌・・・file-name・峨□縺代・迚ｹ蛻･縺ｫ險ｱ蜿ｯ
            if (!target.classList.contains('file-name')) {
                return;
            }
        }

        // 繝医Μ繝励Ν繧ｸ繝・・繝ｭ繝・け・夊ｷ晞屬(10px)繝ｻ譎る俣(150ms)繝ｻ繝懊ち繝ｳ迥ｶ諷・謚ｼ荳倶ｸｭ)
        const startX = e.clientX;
        const startY = e.clientY;
        const startTime = Date.now();

        const onPointerMove = (moveEvent: PointerEvent) => {
            const dx = moveEvent.clientX - startX;
            const dy = moveEvent.clientY - startY;
            const elapsed = Date.now() - startTime;

            if ((Math.abs(dx) > 10 || Math.abs(dy) > 10) && elapsed > 150 && moveEvent.buttons === 1) {
                cleanup();
                try {
                    getCurrentWindow().startDragging();
                } catch (err) {
                    console.error('startDragging failed', err);
                }
            }
        };

        const onPointerUp = () => cleanup();
        const cleanup = () => {
            window.removeEventListener('pointermove', onPointerMove);
            window.removeEventListener('pointerup', onPointerUp);
        };

        e.preventDefault();
        e.stopPropagation();
        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUp);
    }, [isEditing]);



    // [New] Sync editBodyRef
    useEffect(() => {
        editBodyRef.current = editBody;
    }, [editBody]);

    // [New] Sync currentTags with rawFrontmatter
    useEffect(() => {
        if (!rawFrontmatter) {
            setCurrentTags([]);
            return;
        }
        // Minimal RegEx parser for "tags: [a, b, c]"
        const tagsMatch = rawFrontmatter.match(/tags:\s*\[([^\]]*)\]/);
        if (tagsMatch) {
            const parsed = tagsMatch[1]
                .split(',')
                .map(t => t.trim())
                .filter(t => t.length > 0);
            setCurrentTags(parsed);
        } else {
            setCurrentTags([]);
        }
    }, [rawFrontmatter]);

    // 繝帙ヰ繝ｼ邂｡逅・
    useEffect(() => {
        const handleGlobalPointer = (e: PointerEvent) => {
            if (!shellRef.current) return;
            const rect = shellRef.current.getBoundingClientRect();

            const isInside = (
                e.clientX >= rect.left + 0.5 &&
                e.clientX <= rect.right - 0.5 &&
                e.clientY >= rect.top + 0.5 &&
                e.clientY <= rect.bottom - 0.5
            );

            if (!isInside && isHover) {
                setIsHover(false);
                setIsDraggableArea(false);
                setIsEditableArea(false);
                setIsCornerArea(false);
            } else if (isInside) {
                const target = e.target as HTMLElement;
                const textElement = target.closest('p, h1, h2, h3, li, span, strong, em, code, pre');
                const interactive = target.closest('button, textarea, input, .file-name');

                const gap = 15;
                const nearLeft = e.clientX < rect.left + gap;
                const nearRight = e.clientX > rect.right - gap;
                const nearTop = e.clientY < rect.top + gap;
                const nearBottom = e.clientY > rect.bottom - gap;
                const isCorner = (nearLeft || nearRight) && (nearTop || nearBottom);
                setIsCornerArea(isCorner);

                if (interactive) {
                    setIsDraggableArea(false);
                    setIsEditableArea(false);
                } else if (textElement) {
                    setIsDraggableArea(false);
                    setIsEditableArea(true);
                } else {
                    setIsDraggableArea(true);
                    setIsEditableArea(false);
                }
            }
        };

        const handleReset = () => {
            setIsHover(false);
            setIsDraggableArea(false);
            setIsEditableArea(false);
            setIsCornerArea(false);
        };

        window.addEventListener('pointermove', handleGlobalPointer);
        window.addEventListener('pointerleave', handleReset);
        window.addEventListener('blur', handleReset);
        return () => {
            window.removeEventListener('pointermove', handleGlobalPointer);
            window.removeEventListener('pointerleave', handleReset);
            window.removeEventListener('blur', handleReset);
        };
    }, [isHover]);

    // [New] Dirty Check
    const isDirty = isEditing
        ? (editBody !== content) || savePending
        : savePending;




    // Context Menu Logic
    const lastContextMenuPos = useRef<{ x: number, y: number } | null>(null);
    const shouldReopenMenu = useRef(false);

    const showContextMenu = useCallback(async (x?: number, y?: number) => {
        if (!selectedFile) return;

        try {
            // Import menu classes
            const { Menu, MenuItem, Submenu, PredefinedMenuItem } = await import('@tauri-apps/api/menu');
            const { getCurrentWindow } = await import('@tauri-apps/api/window');

            // Filename display            // Common Items
            const filenameItem = await MenuItem.new({
                id: 'ctx_filename',
                text: getFileName(selectedFile.path),
                enabled: false,
            });

            const separator1 = await PredefinedMenuItem.new({ item: 'Separator' });

            const openFolderItem = await MenuItem.new({
                id: 'ctx_open_folder',
                text: `唐 ${t('menu.openFolder')}`,
                action: async () => {
                    await invoke('fusen_open_containing_folder', { path: selectedFile.path });
                }
            });

            const newNoteItem = await MenuItem.new({
                id: 'ctx_new_note',
                text: `統 ${t('menu.newNote')}`,
                action: async () => { /* ... existing logic ... */
                    try {
                        const normalizedPath = selectedFile.path.replace(/\\/g, '/');
                        const folderPath = normalizedPath.substring(0, normalizedPath.lastIndexOf('/'));
                        // Use default context "memo" for new notes instead of inheriting
                        const note = await invoke<Note>('fusen_create_note', { folderPath, context: 'memo' });
                        const { WebviewWindow } = await import('@tauri-apps/api/webviewWindow');
                        const sanitizedPath = note.meta.path.replace(/[^a-zA-Z0-9]/g, '_');
                        const label = `note_${sanitizedPath}`;
                        new WebviewWindow(label, {
                            url: `/?path=${encodeURIComponent(note.meta.path)}&isNew=1`, // Fix 1: Add isNew=1
                            title: 'Sticky Note',
                            width: 400,
                            height: 300,
                            decorations: false,
                            transparent: true
                        });
                    } catch (e) {
                        console.error('New note error', e);
                    }
                }
            });

            // Color Items
            const colorItems = [
                await MenuItem.new({ id: 'ctx_color_blue', text: `鳩 ${t('menu.colors.blue')}`, action: () => handleColorChange('#80d8ff') }),
                await MenuItem.new({ id: 'ctx_color_pink', text: `減 ${t('menu.colors.pink')}`, action: () => handleColorChange('#ffcdd2') }),
                await MenuItem.new({ id: 'ctx_color_yellow', text: `兆 ${t('menu.colors.yellow')}`, action: () => handleColorChange('#f7e9b0') })
            ];
            const colorSubmenu = await Submenu.new({ id: 'ctx_color_submenu', text: `耳 ${t('menu.changeColor')}`, items: colorItems });

            const separatorCommon = await PredefinedMenuItem.new({ item: 'Separator' });

            // --- Dynamic Part ---
            let menuItems: any[] = [
                filenameItem,
                separator1,
                openFolderItem,
                await PredefinedMenuItem.new({ item: 'Separator' }), // Sep before New Note
                newNoteItem,
                colorSubmenu,
                separatorCommon
            ];

            if (isTagDeleteMode) {
                console.log('[ShowContextMenu] Building menu in DELETE MODE.');
                // DELETE MODE: Flattened Tags
                menuItems.push(await MenuItem.new({ id: 'header_del', text: `笞・・${t('menu.deleteMode')}`, enabled: false }));

                try {
                    const tags = await invoke<string[]>('fusen_get_all_tags');
                    console.log('[ShowContextMenu] Fetched tags for delete mode:', tags);
                    if (tags.length > 0) {
                        for (const tag of tags) {
                            menuItems.push(await MenuItem.new({
                                id: `ctx_del_tag_${tag}`,
                                text: `卵・・${tag}`,
                                action: async () => {
                                    console.log('Requesting delete for:', tag);
                                    setTagToDelete(tag);
                                }
                            }));
                        }
                    } else {
                        menuItems.push(await MenuItem.new({ id: 'ctx_no_tags', text: `(${t('menu.noTags')})`, enabled: false }));
                    }
                } catch (e) { console.error('Failed to load tags in delete mode:', e); }

                menuItems.push(await PredefinedMenuItem.new({ item: 'Separator' }));
                menuItems.push(await MenuItem.new({
                    id: 'ctx_exit_mode',
                    text: `筮・ｸ・${t('menu.normalMode')}`,
                    action: () => {
                        shouldReopenMenu.current = true;
                        setIsTagDeleteMode(false);
                    }
                }));

            } else {
                console.log('[ShowContextMenu] Building menu in NORMAL MODE.');
                // NORMAL MODE: Tag Submenu
                const tagNewItem = await MenuItem.new({
                    id: 'ctx_tag_new',
                    text: `筐・${t('menu.addTag')}`,
                    action: async () => {
                        /* Reuse logic to fetch tags and show modal */
                        try {
                            const tags = await invoke<string[]>('fusen_get_all_tags');
                            setAllTags(tags);
                            if (selectedFile) {
                                const note = await invoke<Note>('fusen_read_note', { path: selectedFile.path });
                                const { front } = splitFrontMatter(note.body);
                                const tagsMatch = front.match(/tags:\s*\[([^\]]*)\]/);
                                if (tagsMatch) setCurrentTags(tagsMatch[1].split(',').map(t => t.trim()).filter(t => t));
                                else setCurrentTags([]);
                            }
                            setShowTagModal(true);
                            setTagInputValue('');
                        } catch (e) { console.error('Failed to load tags for new tag modal:', e); }
                    }
                });

                let tagSubItems: any[] = [tagNewItem];
                try {
                    const tags = await invoke<string[]>('fusen_get_all_tags');
                    console.log('[ShowContextMenu] Fetched tags for normal mode:', tags);
                    // Fetch current file tags logic
                    let currentNoteTags: string[] = [];
                    if (selectedFile) {
                        const note = await invoke<Note>('fusen_read_note', { path: selectedFile.path });
                        const { front } = splitFrontMatter(note.body);
                        const tagsMatch = front.match(/tags:\s*\[([^\]]*)\]/);
                        if (tagsMatch) currentNoteTags = tagsMatch[1].split(',').map(t => t.trim()).filter(t => t);
                    }

                    if (tags.length > 0) {
                        tagSubItems.push(await PredefinedMenuItem.new({ item: 'Separator' }));
                        for (const tag of tags) {
                            const isChecked = currentNoteTags.includes(tag);
                            tagSubItems.push(await MenuItem.new({
                                id: `ctx_tag_${tag}`,
                                text: isChecked ? `笘・${tag}` : `笘・${tag}`,
                                action: async () => {
                                    try {
                                        if (!selectedFile) return;

                                        // [Fix] Resolve conflict: save current state first to avoid overwriting tags later
                                        await saveNote(selectedFile.path, editBody, rawFrontmatter, false);
                                        setSavePending(false);

                                        if (isChecked) await invoke('fusen_remove_tag', { path: selectedFile.path, tag });
                                        else await invoke('fusen_add_tag', { path: selectedFile.path, tag });
                                        shouldReopenMenu.current = true;
                                        // Refresh local
                                        const note = await invoke<Note>('fusen_read_note', { path: selectedFile.path });
                                        const { front, body } = splitFrontMatter(note.body);
                                        setRawFrontmatter(front);
                                        setContent(body);
                                        setEditBody(body);
                                    } catch (e) { console.error('Failed to toggle tag:', e); }
                                }
                            }));
                        }
                        tagSubItems.push(await PredefinedMenuItem.new({ item: 'Separator' }));
                        tagSubItems.push(await MenuItem.new({
                            id: 'ctx_enter_del_mode',
                            text: `肌 ${t('menu.deleteMode')}`,
                            action: () => {
                                shouldReopenMenu.current = true;
                                setIsTagDeleteMode(true);
                            }
                        }));
                    } else {
                        tagSubItems.push(await PredefinedMenuItem.new({ item: 'Separator' }));
                        tagSubItems.push(await MenuItem.new({
                            id: 'ctx_no_tags_normal',
                            text: `(${t('menu.noTags')})`,
                            enabled: false
                        }));
                    }
                } catch (e) { console.error('Failed to load tags for submenu:', e); }

                const tagSubmenu = await Submenu.new({ id: 'ctx_tags_submenu', text: `捷・・${t('menu.tags')}`, items: tagSubItems });
                menuItems.push(tagSubmenu);
            }

            // Delete Note Item (Always available at bottom)
            menuItems.push(await PredefinedMenuItem.new({ item: 'Separator' }));
            menuItems.push(await MenuItem.new({
                id: 'ctx_delete',
                text: `卵・・${t('menu.delete')}`,
                action: async () => {
                    // [Sound] 險ｭ螳壹↓蝓ｺ縺･縺・※蜑企勁髻ｳ繧貞・逕・
                    await playDeleteSound();

                    // 髻ｳ縺瑚◇縺薙∴繧九ｈ縺・↓蟆代＠蠕・▽
                    await new Promise(resolve => setTimeout(resolve, 300));

                    await invoke('fusen_move_to_trash', { path: selectedFile.path });
                }
            }));

            menuRef.current = await Menu.new({ id: 'context_menu', items: menuItems });


            // Use provided coordinates OR last known position OR cursor
            if (x !== undefined && y !== undefined) {
                const { LogicalPosition } = await import('@tauri-apps/api/dpi');
                await menuRef.current.popup(new LogicalPosition(x, y));
            } else {
                await menuRef.current.popup();
            }

        } catch (err) {
            console.error('Failed to show context menu', err);
        }
    }, [selectedFile, isTagDeleteMode, loadFileContent, noteBackgroundColor, rawFrontmatter, setEditBody, setSavePending, t]);

    const handleEditBlur = useCallback(async () => { // Parameterless
        // [Ref Stability Check]
        // This function is now stable. It captures Refs (stable) and State (needs deps).
        // Since we use Refs for 'editBody' and 'isCommitting', we only really need 'selectedFile' and 'saveNote'.

        if (!selectedFile) return;
        if (isCommittingRef.current) {
            console.log('[DEBUG] handleEditBlur skipped: Already committing.');
            return;
        }

        isCommittingRef.current = true;
        setSavePending(false); // Cancel pending auto-save NOW

        console.log('[DEBUG] handleEditBlur (Commit) triggered. Ref Body:', editBodyRef.current?.length);

        // [Strict] Get fresh content directly from editor to avoid state lag
        let currentBody = editBodyRef.current;
        if (editorRef.current?.getContent) {
            currentBody = editorRef.current.getContent();
            // Sync state immediately
            setEditBody(currentBody);
            editBodyRef.current = currentBody;
        }

        setIsEditing(false);
        lastEditEndedAt.current = Date.now();

        // 邨ｱ荳縺輔ｌ縺滉ｿ晏ｭ伜・逅・ｒ菴ｿ逕ｨ
        try {
            await saveNote(selectedFile.path, currentBody, rawFrontmatter, true);
        } catch (e) {
            console.error('Save failed in blur', e);
        } finally {
            isCommittingRef.current = false;
        }
    }, [selectedFile, rawFrontmatter, saveNote]); // Minimal dependencies

    // Handle initial right click (Dependencies updated)
    useEffect(() => {
        const handleContextMenu = async (e: MouseEvent) => {
            e.preventDefault();
            if (isEditing) {
                await handleEditBlur();
            }
            lastContextMenuPos.current = { x: e.clientX, y: e.clientY };
            showContextMenu(e.clientX, e.clientY);
        };
        window.addEventListener('contextmenu', handleContextMenu);
        return () => window.removeEventListener('contextmenu', handleContextMenu);
    }, [showContextMenu, isEditing, handleEditBlur]); // handleEditBlur is now stable(ish)

    // Handle auto-reopen on mode switch
    useEffect(() => {
        if (shouldReopenMenu.current && lastContextMenuPos.current) {
            shouldReopenMenu.current = false;
            // Short delay to ensure previous menu is fully closed/state updated
            setTimeout(() => {
                showContextMenu(lastContextMenuPos.current?.x, lastContextMenuPos.current?.y);
            }, 50);
        }
    }, [isTagDeleteMode, showContextMenu]);

    // [New] Edit Mode Boundaries (Explicit Exit)
    useEffect(() => {
        if (!isEditing) return;

        const onWindowBlur = () => {
            console.log('[Boundary] Window Blur Detected. Committing.');
            handleEditBlur();
        };

        window.addEventListener('blur', onWindowBlur);
        return () => {
            console.log('[Boundary] Cleanup blur listener');
            window.removeEventListener('blur', onWindowBlur);
        };
    }, [isEditing, handleEditBlur]);

    // 繧ｳ繝ｳ繝・く繧ｹ繝医Γ繝九Η繝ｼ繧｢繧ｯ繧ｷ繝ｧ繝ｳ
    const handleToggleAlwaysOnTop = async (enabled: boolean) => {
        if (!selectedFile) return;
        try {
            await invoke('fusen_toggle_always_on_top', {
                path: selectedFile.path,
                enable: enabled
            });
            setSelectedFile(prev => prev ? { ...prev, alwaysOnTop: enabled } : null);
        } catch (e) {
            console.error('Failed to toggle always on top', e);
        }
    };




    // [New] Edit Mode Boundaries (Explicit Exit) - Moved here to avoid "used before declaration"
    useEffect(() => {
        if (!isEditing) return;

        const onWindowBlur = () => {
            console.log('[Boundary] Window Blur. Committing.');
            handleEditBlur(); // No args
        };

        window.addEventListener('blur', onWindowBlur);
        return () => {
            window.removeEventListener('blur', onWindowBlur);
        };
    }, [isEditing, handleEditBlur]); // editBodyRef is stable

    const handleDuplicate = async () => {
        if (!selectedFile) return;
        try {
            // 迴ｾ蝨ｨ縺ｮ繝輔か繝ｫ繝繝代せ繧貞叙蠕・
            const normalizedPath = selectedFile.path.replace(/\\/g, '/');
            const folderPath = normalizedPath.substring(0, normalizedPath.lastIndexOf('/'));

            // 譁ｰ隕上ヮ繝ｼ繝井ｽ懈・・医さ繝ｳ繝・く繧ｹ繝育ｶ呎価・・
            const newNote = await invoke<Note>('fusen_create_note', {
                folderPath,
                context: selectedFile.context
            });

            // 蜀・ｮｹ繧堤樟蝨ｨ縺ｮ蜀・ｮｹ縺ｧ荳頑嶌縺堺ｿ晏ｭ假ｼ医Γ繧ｿ繝・・繧ｿ蜷ｫ繧・・
            await invoke('fusen_save_note', {
                path: newNote.meta.path,
                body: editBody,
                frontmatterRaw: rawFrontmatter,
                allowRename: false // Initial save for duplicate, no rename needed
            });

            // 譁ｰ縺励＞繧ｦ繧｣繝ｳ繝峨え繧帝幕縺・
            await emit('fusen:open_note', { path: newNote.meta.path });
        } catch (e) {
            console.error('Duplicate failed', e);
        }
    };

    const handleOpenFolder = async () => {
        if (!selectedFile) return;
        await invoke('fusen_open_containing_folder', { path: selectedFile.path });
    };

    const handleColorChange = (newColor: string) => {
        console.log('[COLOR] Changing to:', newColor);
        setNoteBackgroundColor(newColor);
        setRawFrontmatter(prev => updateFrontmatterValue(prev, 'backgroundColor', newColor));
        setSavePending(true);
        if (shellRef.current) {
            shellRef.current.style.setProperty('background-color', newColor, 'important');
        }
    };

    // Global Tag Delete Handler
    const executeTagDelete = async () => {
        if (!tagToDelete) return;

        console.log('[Frontend] Executing global delete for:', tagToDelete);
        try {
            const count = await invoke<number>('fusen_delete_tag_globally', { tag: tagToDelete });
            console.log(`[Frontend] Deleted tag ${tagToDelete} from ${count} notes.`);
            if (count === 0) {
                console.warn('[Frontend] Backend reported 0 notes modified. Is the tag matching correct?');
            }

            // Wait a bit for backend state/file IO to settle (mitigate race condition)
            await new Promise(resolve => setTimeout(resolve, 300));

            // STAY in Delete Mode and reopen menu to show updated list
            shouldReopenMenu.current = true;

            if (selectedFile) loadFileContent(selectedFile);
        } catch (e) {
            console.error('Failed to delete tag globally:', e);
            alert(`繧ｿ繧ｰ縺ｮ蜑企勁縺ｫ螟ｱ謨励＠縺ｾ縺励◆縲・n繧ｨ繝ｩ繝ｼ: ${e}`);
        } finally {
            setTagToDelete(null);
        }
    };

    // Native Context Menu Action Listener
    useEffect(() => {
        if (!selectedFile) return;

        const unlisten = (async () => {
            const win = getCurrentWindow();
            return await win.listen<any>('fusen:context_action', async (event) => {
                const { action, path } = event.payload;
                console.log('[NativeMenu] Action:', action, 'Path:', path);

                // Ignore if not for this note (pathsEqual for cross-platform compatibility)
                if (!pathsEqual(path, selectedFile.path)) return;

                if (action === 'ctx_open_folder') {
                    // Rust side handles this mostly, but we can double check or do nothing
                } else if (action.startsWith('ctx_color_')) {
                    const color = action.replace('ctx_color_', '');
                    handleColorChange(color);
                } else if (action === 'ctx_toggle_top') {
                    // Toggle current state
                    handleToggleAlwaysOnTop(!selectedFile.always_on_top);
                } else if (action === 'ctx_new_note') {
                    // Reuse "New Note" logic
                    const normalizedPath = selectedFile.path.replace(/\\/g, '/');
                    const folderPath = normalizedPath.substring(0, normalizedPath.lastIndexOf('/'));
                    try {
                        const note = await invoke<Note>('fusen_create_note', { folderPath, context: '' });
                        await emit('fusen:open_note', { path: note.meta.path });
                    } catch (e) {
                        console.error('New note failed', e);
                    }
                } else if (action === 'ctx_duplicate') {
                    handleDuplicate();
                } else if (action === 'ctx_trash') {
                    setSavePending(false);
                    await invoke('fusen_move_to_trash', { path: selectedFile.path });
                    await getCurrentWindow().close();
                }
            });
        })();

        return () => {
            unlisten.then(f => f());
        };
    }, [selectedFile, noteBackgroundColor, savePending, rawFrontmatter, editBody, content]);

    // 繧ｿ繧ｰ霑ｽ蜉繝上Φ繝峨Λ繝ｼ
    const handleAddTag = async () => {
        if (!selectedFile || !tagInputValue.trim()) return;

        try {
            await invoke('fusen_add_tag', {
                path: selectedFile.path,
                tag: tagInputValue.trim()
            });

            // 繝｢繝ｼ繝繝ｫ繧帝哩縺倥ｋ
            setShowTagModal(false);
            setTagInputValue('');

            // 蜈ｨ繧ｿ繧ｰ繧貞・蜿門ｾ・
            const tags = await invoke<string[]>('fusen_get_all_tags');
            setAllTags(tags);

            // 繝弱・繝医ｒ蜀崎ｪｭ縺ｿ霎ｼ縺ｿ縺励※迴ｾ蝨ｨ縺ｮ繧ｿ繧ｰ繧よ峩譁ｰ
            const note = await invoke<Note>('fusen_read_note', { path: selectedFile.path });
            const { front, body } = splitFrontMatter(note.body);
            setRawFrontmatter(front);
            setContent(body);
            setEditBody(body);

            // 迴ｾ蝨ｨ縺ｮ繧ｿ繧ｰ繧呈峩譁ｰ
            const tagsMatch = front.match(/tags:\s*\[([^\]]*)\]/);
            if (tagsMatch) {
                const noteTags = tagsMatch[1].split(',').map(t => t.trim()).filter(t => t);
                setCurrentTags(noteTags);
            }
        } catch (e) {
            console.error('Failed to add tag:', e);
        }
    };

    if (loading) return <div>Loading...</div>;
    // Markdown謖ｿ蜈･繝倥Ν繝代・
    const insertMarkdown = (marker: string) => {
        if (!textareaRef.current) return;
        const textarea = textareaRef.current;
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        const text = textarea.value;
        const before = text.substring(0, start);
        const selection = text.substring(start, end);
        const after = text.substring(end);

        const newText = `${before}${marker}${selection}${marker}${after}`;
        setEditBody(newText);
        setSavePending(true); // 蜊ｳ蠎ｧ縺ｫ菫晏ｭ倥く繝･繝ｼ縺ｸ

        // 繧ｫ繝ｼ繧ｽ繝ｫ菴咲ｽｮ繧貞ｾｩ蜈・ｼ磯∈謚樒ｯ・峇繧堤ｶｭ謖・ｼ・
        requestAnimationFrame(() => {
            if (textareaRef.current) {
                textareaRef.current.focus();
                textareaRef.current.setSelectionRange(start + marker.length, end + marker.length);
            }
        });
    };

    // 繝帙ヰ繝ｼ繝舌・ (邱ｨ髮・Δ繝ｼ繝画凾縺ｯ繝・・繝ｫ繝舌・)
    const HoverBar = ({ show }: { show: boolean }) => {
        if (!isEditing) return null;
        return (
            <div
                className="hoverBar"
                style={{
                    opacity: (show || isEditing) ? 1 : 0,
                    visibility: (show || isEditing) ? 'visible' : 'hidden',
                    pointerEvents: (show || isEditing) ? 'auto' : 'none',
                    transition: 'opacity 0.1s ease',
                    display: 'flex',
                    flexDirection: 'column', // Vertical layout as requested
                    alignItems: 'center',
                    gap: '8px',
                    padding: '4px',
                    backgroundColor: 'rgba(255,255,255,0.4)',
                    borderRadius: '8px',
                    backdropFilter: 'blur(4px)',
                    zIndex: 200
                }}
            >
                {isEditing ? (
                    <>
                        <button
                            onPointerDown={(e) => {
                                e.preventDefault();
                                e.stopPropagation();
                            }}
                            onClick={() => editorRef.current?.insertBold()}
                            className="font-bold text-red-600 hover:bg-gray-100 px-2 min-w-[32px] rounded text-sm flex items-center justify-center whitespace-nowrap"
                            title="螟ｪ蟄・(襍､)"
                        >
                            B
                        </button>
                        <button
                            onPointerDown={(e) => {
                                e.preventDefault();
                                e.stopPropagation();
                            }}
                            onClick={() => editorRef.current?.insertHeading1()}
                            className="font-bold text-gray-700 hover:bg-gray-100 px-2 min-w-[32px] rounded text-sm flex items-center justify-center whitespace-nowrap"
                            title="隕句・縺・"
                        >
                            <span style={{ fontSize: '14px', position: 'relative', top: '-1px' }}>H<sub style={{ bottom: '0', fontSize: '10px' }}>1</sub></span>
                        </button>
                        <button
                            onPointerDown={(e) => {
                                e.preventDefault();
                                e.stopPropagation();
                            }}
                            onClick={() => editorRef.current?.insertList()}
                            className="text-gray-700 hover:bg-gray-100 px-2 min-w-[32px] rounded flex items-center justify-center"
                            title="邂・擅譖ｸ縺・
                        >
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round">
                                <line x1="9" y1="6" x2="20" y2="6"></line>
                                <line x1="9" y1="12" x2="20" y2="12"></line>
                                <line x1="9" y1="18" x2="20" y2="18"></line>
                                <circle cx="5" cy="6" r="1.5" fill="currentColor"></circle>
                                <circle cx="5" cy="12" r="1.5" fill="currentColor"></circle>
                                <circle cx="5" cy="18" r="1.5" fill="currentColor"></circle>
                            </svg>
                        </button>
                        <button
                            onPointerDown={(e) => {
                                e.preventDefault();
                                e.stopPropagation();
                            }}
                            onClick={() => editorRef.current?.insertCheckbox()}
                            className="text-gray-700 hover:bg-gray-100 px-2 min-w-[32px] rounded flex items-center justify-center"
                            title="繝√ぉ繝・け繝懊ャ繧ｯ繧ｹ"
                        >
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                <polyline points="9 11 12 14 22 4"></polyline>
                            </svg>
                        </button>
                    </>
                ) : null}
            </div>
        );
    };

    if (!urlPath) {
        return <div className="p-8">No path parameter</div>;
    }

    return (
        <div
            ref={shellRef}
            className="noteShell h-screen overflow-hidden flex flex-col"
            style={{ backgroundColor: noteBackgroundColor }}
        >
            <style>{`
                /* Scoped Scrollbar Styles */
                .notePaper::-webkit-scrollbar {
                    width: 12px;
                    height: 12px;
                }
                .notePaper::-webkit-scrollbar-track {
                    background: transparent;
                }
                .notePaper::-webkit-scrollbar-thumb {
                    background-color: rgba(0, 0, 0, 0.2);
                    border-radius: 6px;
                    border: 3px solid transparent;
                    background-clip: content-box;
                }
                .notePaper::-webkit-scrollbar-thumb:hover {
                    background-color: rgba(0, 0, 0, 0.5);
                }
            `}</style>

            {/* [NEW] Persistent Sticky Header for Tags & Drag */}
            <header
                style={{
                    padding: '8px 18px 4px 18px',
                    display: 'flex',
                    flexDirection: 'row',
                    justifyContent: 'flex-end',
                    alignItems: 'center',
                    flexShrink: 0,
                    zIndex: 100,
                    WebkitAppRegion: 'drag',
                    cursor: 'move',
                    minHeight: '32px'
                } as any}
            >
                {/* Right: Tag Chips Display & Status */}
                <div style={{
                    display: 'flex',
                    gap: '4px',
                    overflow: 'hidden',
                    whiteSpace: 'nowrap',
                    pointerEvents: 'auto',
                    justifyContent: 'flex-end'
                }}>
                    {currentTags.length > 0 && (() => {
                        const MAX_DISPLAY = 5;
                        const displayTags = currentTags.slice(0, MAX_DISPLAY).map(tag =>
                            tag.length > 10 ? tag.substring(0, 10) + '窶ｦ' : tag
                        );
                        if (currentTags.length > MAX_DISPLAY) {
                            displayTags.push(`+${currentTags.length - MAX_DISPLAY}`);
                        }

                        return displayTags.map((tag, i) => (
                            <span key={i} style={{
                                backgroundColor: 'rgba(0,0,0,0.08)',
                                padding: '1px 6px',
                                borderRadius: '4px',
                                fontSize: '11px',
                                color: 'rgba(0,0,0,0.5)',
                                flexShrink: 0,
                                cursor: 'default'
                            }}>
                                {tag}
                            </span>
                        ));
                    })()}
                    {isEditing && (
                        <span style={{ color: '#ef4444', fontSize: '14px', marginLeft: '6px', alignSelf: 'center' }}>笳・/span>
                    )}
                </div>
            </header>

            <main
                className="flex-1 overflow-y-auto w-full notePaper noteMain pb-10"
                style={{
                    backgroundColor: noteBackgroundColor,
                    display: 'flex',
                    flexDirection: 'column',
                    padding: '0 18px 12px 18px', // Horizontal 18px matching header
                    boxSizing: 'border-box',
                    position: 'relative'
                }}
            >
                {/* Floating Vertical Toolbar (Pointer events auto to allow clicking) */}
                <div style={{
                    position: 'sticky',
                    top: '0px',
                    right: '0px',
                    zIndex: 200,
                    pointerEvents: 'none',
                    height: 0, // Ensure it doesn't take vertical space
                    display: 'flex',
                    justifyContent: 'flex-end'
                }}>
                    <HoverBar show={isHover} />
                </div>
                {/* The old file-name div is removed/simplified to just a spacer or hidden */}
                {
                    loading ? (
                        <div className="text-center text-gray-300 py-8 text-xs font-mono opacity-30">Loading...</div>
                    ) : isEditing ? (
                        <div
                            className="editorHost notePaper"
                            ref={editorHostRef} // [New Ref]
                            style={{
                                flex: 1,
                                display: 'flex',
                                flexDirection: 'column',
                                cursor: isEditing ? 'text' : 'default' // Add visual cue
                            }}
                        >
                            <RichTextEditor
                                ref={editorRef}
                                value={editBody}
                                onChange={(newValue) => {
                                    setEditBody(newValue);
                                    setSavePending(true);
                                }}

                                onKeyDown={(e) => {
                                    if (e.key === 'Escape') handleEditBlur();
                                }}
                                backgroundColor={noteBackgroundColor}
                                cursorPosition={cursorPosition}
                                isNewNote={isNewNote} // [NEW] state縺九ｉ貂｡縺・
                                fontSize={noteFontSize} // 險ｭ螳壹°繧峨・繝輔か繝ｳ繝医し繧､繧ｺ
                            />
                        </div>
                    ) : (
                        <article
                            className="notePaper max-w-none"
                            style={{
                                backgroundColor: noteBackgroundColor,
                                whiteSpace: 'pre-wrap',
                                cursor: 'text',
                                padding: 0, // 隕ｪ縺ｮmain縺ｧ繝代ョ繧｣繝ｳ繧ｰ縺励※縺・ｋ縺ｮ縺ｧ0縺ｫ縺吶ｋ
                                fontSize: `${noteFontSize}px`, // 險ｭ螳壹°繧峨・繝輔か繝ｳ繝医し繧､繧ｺ
                                fontFamily: '"BIZ UDPGothic", "Meiryo", "Yu Gothic UI", sans-serif',
                                lineHeight: '1.4',
                                letterSpacing: '0.01em'
                            }}
                            onPointerDown={onArticlePointerDown} // 繝峨Λ繝・げ蛻､螳夂畑縺ｯ谿九☆
                            // onPointerUp={onArticlePointerUp} // [Deleted] 繧ｷ繝ｳ繧ｰ繝ｫ繧ｯ繝ｪ繝・け邱ｨ髮・幕蟋九ｒ蜑企勁
                            onDoubleClick={(e) => {
                                e.stopPropagation();
                                handleEditStart();
                            }}
                            data-tauri-drag-region // [New] 繝阪う繝・ぅ繝悶ラ繝ｩ繝・げ譛牙柑蛹・
                        >
                            {content ? (
                                <div style={{ whiteSpace: 'pre-wrap' }}>
                                    {content.split('\n').map((line, i) => {
                                        // 1陦後・蜈ｱ騾壹せ繧ｿ繧､繝ｫ
                                        const lineStyle: React.CSSProperties = {
                                            margin: 0,
                                            padding: 0,
                                            lineHeight: '1.4',
                                            minHeight: '1.4em', // 14.7px逶ｸ蠖薙ゅお繝・ぅ繧ｿ縺ｮ1陦後→遒ｺ螳溘↓荳閾ｴ縺輔○繧・
                                            display: 'flex',
                                            alignItems: 'flex-start'
                                        };

                                        const baseOffset = lineOffsets[i] || 0;

                                        if (line.trim() === '') {
                                            return <div key={i} data-line-index={i} style={lineStyle} data-src-start={baseOffset}>&nbsp;</div>;
                                        }

                                        if (line.startsWith('# ')) {
                                            // Heading: start text after "# " (length 2)
                                            return (
                                                <div key={i} data-line-index={i} style={{ ...lineStyle, fontWeight: 700, fontSize: '1.1em' }}>
                                                    <span
                                                        style={{ color: '#ff8c00', marginRight: '4px', userSelect: 'none' }}
                                                        data-src-start={baseOffset}
                                                    ># </span>
                                                    <span data-src-start={baseOffset + 2}>
                                                        {parseLinks(line.substring(2), baseOffset + 2)}
                                                    </span>
                                                </div>
                                            );
                                        }

                                        // 繝√ぉ繝・け繝懊ャ繧ｯ繧ｹ (繧ｿ繧ｹ繧ｯ繝ｪ繧ｹ繝・
                                        const taskMatch = line.match(/^([\-\*\+]\s+\[)([ xX])(\]\s+.*)$/);
                                        if (taskMatch) {
                                            const isChecked = taskMatch[2].toLowerCase() === 'x';

                                            // Calculate offset for the text part
                                            // Structure: [Marker] [Checkbox] [Text]
                                            // "- [ ] " is length 6 if marker is "-".
                                            // Robust calc: 
                                            // line.length - text.length
                                            const text = taskMatch[3].substring(2);
                                            const textStart = baseOffset + (line.length - text.length);

                                            return (
                                                <div key={i} data-line-index={i} style={lineStyle}>
                                                    <span
                                                        onClick={(e) => {
                                                            e.stopPropagation(); // 邱ｨ髮・Δ繝ｼ繝臥ｧｻ陦後ｒ髦ｲ縺・
                                                            handleToggleCheckbox(i);
                                                        }}
                                                        data-interactable="true"
                                                        style={{
                                                            marginRight: '6px',
                                                            color: isChecked ? '#4caf50' : '#888',
                                                            flexShrink: 0,
                                                            display: 'inline-block',
                                                            width: '1em',
                                                            textAlign: 'center',
                                                            cursor: 'pointer', // 謚ｼ縺帙ｋ縺薙→縺悟・縺九ｋ繧医≧縺ｫ
                                                            userSelect: 'none'
                                                        }}
                                                        title={isChecked ? '譛ｪ螳御ｺ・↓縺吶ｋ' : '螳御ｺ・↓縺吶ｋ'}
                                                        data-src-start={baseOffset} // Icon click -> start of line
                                                    >
                                                        {isChecked ? '笘・ : '笘・}
                                                    </span>
                                                    <span
                                                        style={{ textDecoration: isChecked ? 'line-through' : 'none', opacity: isChecked ? 0.6 : 1 }}
                                                        data-src-start={textStart}
                                                    >
                                                        {parseLinks(text, textStart)}
                                                    </span>
                                                </div>
                                            );
                                        }

                                        // 邂・擅譖ｸ縺・(繝ｪ繧ｹ繝・
                                        const listMatch = line.match(/^[\-\*\+]\s+(.*)$/);
                                        if (listMatch) {
                                            const text = listMatch[1];
                                            const textStart = baseOffset + (line.length - text.length);
                                            return (
                                                <div key={i} data-line-index={i} style={lineStyle}>
                                                    <span style={{
                                                        marginRight: '8px',
                                                        color: '#ff8c00',
                                                        flexShrink: 0,
                                                        display: 'inline-block',
                                                        width: '1em',
                                                        textAlign: 'center'
                                                    }} data-src-start={baseOffset}>窶｢</span>
                                                    <span data-src-start={textStart}>
                                                        {parseLinks(text, textStart)}
                                                    </span>
                                                </div>
                                            );
                                        }

                                        // Normal / Bold
                                        // Split by **bold**
                                        const parts = line.split(/(\*\*[^*]+\*\*)/g);
                                        let currentLineCharIdx = 0;

                                        const rendered = parts.map((part, j) => {
                                            if (part === '') return null;

                                            const partStart = baseOffset + currentLineCharIdx;
                                            const partLength = part.length;

                                            if (part.startsWith('**') && part.endsWith('**')) {
                                                const innerText = part.slice(2, -2);
                                                // Update index for next part
                                                currentLineCharIdx += partLength;

                                                return (
                                                    <strong
                                                        key={j}
                                                        style={{ color: 'red', fontWeight: 'bold' }}
                                                        data-src-start={partStart + 2} // Click inside bold -> start of inner text
                                                    >
                                                        {innerText}
                                                    </strong>
                                                );
                                            }

                                            // Update index for next part
                                            currentLineCharIdx += partLength;

                                            return (
                                                <span key={j} data-src-start={partStart}>
                                                    {parseLinks(part, partStart)}
                                                </span>
                                            );
                                        });

                                        return (
                                            <div key={i} data-line-index={i} style={lineStyle}>
                                                {rendered}
                                            </div>
                                        );
                                    })}
                                </div >
                            ) : (
                                <div className="text-gray-400 text-center py-8 text-xs font-mono opacity-50">
                                    繧ｯ繝ｪ繝・け縺励※邱ｨ髮・ｒ髢句ｧ・
                                </div>
                            )
                            }
                        </article >
                    )
                }

                {/* 
                  縲舌ヵ繝・ち繝ｼ繝峨Λ繝・げ鬆伜沺縲・
                   髢ｲ隕ｧ繝｢繝ｼ繝会ｼ壹ラ繝ｩ繝・げ蜿ｯ閭ｽ鬆伜沺縲√け繝ｪ繝・け縺ｧ邱ｨ髮・
                   邱ｨ髮・Δ繝ｼ繝会ｼ壹け繝ｪ繝・け縺ｧ菫晏ｭ倥＠縺ｦ髢ｲ隕ｧ繝｢繝ｼ繝峨∈謌ｻ繧・
                */}
                <div
                    className="note-footer"
                    style={{
                        flexGrow: 1,
                        minHeight: '100px',
                        cursor: 'grab',
                    }}
                    onPointerDown={(e) => {
                        // 縲仙ｮ悟・迢ｬ遶句梛繝峨Λ繝・げ邂｡逅・・
                        // 隕ｪ隕∫ｴ(noteShell)縺ｸ縺ｮ繧､繝吶Φ繝井ｼ晄眺繧貞ｸｸ縺ｫ驕ｮ譁ｭ縺励∫ｫｶ蜷医ｒ迚ｩ逅・噪縺ｫ謗帝勁縺吶ｋ
                        e.stopPropagation();

                        // 髢ｲ隕ｧ繝｢繝ｼ繝峨°縺､繧ｯ繝ｼ繝ｫ繝繧ｦ繝ｳ譛滄俣螟悶・蝣ｴ蜷医・縺ｿ縲√％縺薙°繧峨ラ繝ｩ繝・げ繧帝幕蟋九☆繧・
                        if (!isEditing && (Date.now() - lastEditEndedAt.current >= 500)) {
                            handleDragStart(e);
                        }
                    }}
                    onClick={() => isEditing && handleEditBlur()}
                    title="繝峨Λ繝・げ縺ｧ遘ｻ蜍・/ 繧ｯ繝ｪ繝・け縺ｧ菫晏ｭ・
                />
            </main >

            {/* 繧ｫ繧ｹ繧ｿ繝繝｢繝ｼ繝繝ｫ繝繧､繧｢繝ｭ繧ｰ - 譁ｰ隕上ち繧ｰ霑ｽ蜉 */}
            {
                showTagModal && (
                    <div style={{
                        position: 'fixed',
                        top: 0,
                        left: 0,
                        width: '100%',
                        height: '100%',
                        backgroundColor: 'rgba(0, 0, 0, 0.5)',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        zIndex: 10000
                    }}>
                        <div style={{
                            backgroundColor: '#fff',
                            padding: '24px',
                            borderRadius: '8px',
                            boxShadow: '0 4px 12px rgba(0,0,0,0.15)',
                            minWidth: '320px',
                            maxWidth: '400px'
                        }}>
                            <h3 style={{ margin: '0 0 16px 0', fontSize: '16px', fontWeight: 'bold' }}>譁ｰ隕上ち繧ｰ繧定ｿｽ蜉</h3>

                            <div style={{ display: 'flex', gap: '8px', marginBottom: '16px' }}>
                                <input
                                    type="text"
                                    value={tagInputValue}
                                    onChange={(e) => setTagInputValue(e.target.value)}
                                    onKeyDown={(e) => {
                                        if (e.key === 'Enter' && tagInputValue.trim()) {
                                            e.preventDefault();
                                            handleAddTag();
                                        } else if (e.key === 'Escape') {
                                            setShowTagModal(false);
                                            setTagInputValue('');
                                        }
                                    }}
                                    placeholder="繧ｿ繧ｰ蜷阪ｒ蜈･蜉・
                                    autoFocus
                                    style={{
                                        flex: 1,
                                        padding: '8px 12px',
                                        border: '1px solid #ddd',
                                        borderRadius: '4px',
                                        fontSize: '14px'
                                    }}
                                />
                                <button
                                    onClick={handleAddTag}
                                    disabled={!tagInputValue.trim()}
                                    style={{
                                        padding: '8px 16px',
                                        border: 'none',
                                        borderRadius: '4px',
                                        backgroundColor: tagInputValue.trim() ? '#28a745' : '#ccc',
                                        color: '#fff',
                                        cursor: tagInputValue.trim() ? 'pointer' : 'not-allowed',
                                        fontSize: '14px',
                                        whiteSpace: 'nowrap'
                                    }}
                                >
                                    霑ｽ蜉
                                </button>
                            </div>

                            <div style={{ display: 'flex', justifyContent: 'flex-end' }}>
                                <button
                                    onClick={() => {
                                        setShowTagModal(false);
                                        setTagInputValue('');
                                    }}
                                    style={{
                                        padding: '6px 12px',
                                        border: '1px solid #ddd',
                                        borderRadius: '4px',
                                        backgroundColor: '#fff',
                                        cursor: 'pointer',
                                        fontSize: '13px'
                                    }}
                                >
                                    繧ｭ繝｣繝ｳ繧ｻ繝ｫ
                                </button>
                            </div>
                        </div>
                    </div>
                )
            }
            {/* Confirmation Dialog for Global Tag Deletion */}
            <ConfirmDialog
                isOpen={!!tagToDelete}
                title="繧ｿ繧ｰ縺ｮ蜑企勁"
                message={`繧ｿ繧ｰ縲・{tagToDelete}縲阪ｒ縺吶∋縺ｦ縺ｮ繝｡繝｢縺九ｉ蜑企勁縺励∪縺吶°・歃n縺薙・謫堺ｽ懊・蜈・↓謌ｻ縺帙∪縺帙ｓ縲Ａ}
                onConfirm={executeTagDelete}
                onCancel={() => {
                    setTagToDelete(null);
                    shouldReopenMenu.current = true;
                }}
            />
        </div >
    );
});

export default StickyNote;

